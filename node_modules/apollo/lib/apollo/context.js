/*!
 * Apollo - Actor Context
 * Copyright (c) 2012 Jake Luer <jake@qualiancy.com>
 * MIT Licensed
 */

/*!
 * Module dependencies
 */

var async = require('breeze-async')
  , debug = require('sherlock')('apollo:context')
  , EventEmitter = require('drip').EnhancedEmitter
  , extend = require('tea-extend')
  , inherits = require('tea-inherits')
  , nextTick = require('breeze-nexttick');

/*!
 * Internal Dependancies
 */

var Actor = require('./actor')
  , Children = require('./children')
  , factory = require('./factory')
  , path = require('./path')
  , Ref = require('./ref')
  , util = require('./util');

/*!
 * Module Constants
 */

var defaults = extend.include('parent', 'ref', 'system');

/*!
 * Primary export
 */

module.exports = Context;

function Context (opts) {
  this.state = 'stopped';

  // empty defaults
  this.parent = null;
  this.ref = null;
  this.system = null;

  // merge allowed properties onto `this`
  opts = defaults(opts || {});
  extend(this, opts);

  // children storage
  this.children = new Children(this.ref);
  debug('%s :: created', this.ref.path);
}

/**
 * ### .actorOf (meta[, options])
 *
 * @param {Mixed} actor constructor or remote address
 * @param {Object} options
 * @name actorOf
 * @api public
 */

Context.prototype.actorOf = function (name, spec, opts) {
  // check valid name
  if (name && !(/^[a-z0-9][a-zA-Z0-9_-]*$/.test(name))) {
    throw new Error('Invalid actor name.');
  }

  // use factory to construct ref
  return factory.actorOf(Context, this.system, this.ref, {
      name: name
    , spec: spec
    , opts: opts
  });
};

Context.prototype.actorFor = function (slug) {
  slug = path.resolve(this.ref.path, slug);
  var reg = this.system.registry.get(slug);
  return reg ? reg.ref : null;
};

Context.prototype.start = function (cb) {
  cb = cb || function () {};
  if (this.state !== 'stopped') return cb();
  this.state = 'starting';
  debug('%s :: starting actor', this.ref.path);

  var self = this
    , path = this.ref.path
    , registry = this.system.registry
    , reg = registry.get(path)
    , emitter = new EventEmitter({ delimiter: '::' })
    , Aktor = util.augment(Actor, reg.spec)
    , actor = new Aktor(reg.ctx, reg.ref, emitter);

  reg.actor = actor;
  reg.emitter = emitter;

  function startListeners (next) {
    var stack = actor.listeners('start');
    async.forEachSeries(stack, function (fn, done) {
      fn('start', function (err) {
        // TODO: handle errs
        // TODO: check if sequence was cancelled
        done();
      });
    }, next);
  }

  function startDelivery (next) {
    if (self.state !== 'starting') {
      debug('%s :: startup actor sequence cancelled', path);
      return next(new Error('Startup sequence cancelled.'));
    }

    self.state = 'started';
    resumeDelivery(registry, self);
    next();
  }

  async.series([
      startListeners
    , startDelivery
  ], cb);
};

Context.prototype.stop = function (cb) {
  cb = cb || function () {};
  var self = this
    , registry = this.system.registry
    , errs = []
    , kids = this.children.keys
    , path = this.ref.path
    , reg = registry.get(path);

  this.state = 'stopping';
  debug('%s :: stopping actor', path);

  // stop delivery of all messages, recursively
  function stopDelivery (next) {
    suspendDelivery(registry, self, next);
  }

  // stop all child actors, recursively
  function stopChildren (next) {
    var kids = self.children.keys;
    async.forEach(kids, function (kid, done) {
      var childRef = self.children.get(kid)
        , childReg = registry.get(childRef.path);
      childReg.ctx.stop(done);
    }, next);
  }

  // run the `stop` stack for this actor
  function stopListeners (next) {
    var stack = reg.actor.listeners('stop');
    async.forEachSeries(stack, function (fn, done) {
      fn('stop', function (err) {
        if (err) errs.push(err);
        done();
      });
    }, next);
  }

  // clean up
  function stopActor (next) {
    var parentReg;

    reg.emitter = null;
    reg.actor = null;
    self.state = 'stopped';

    self.system.unregister(self.ref);

    if (self.parent) {
      parentReg = self.system.registry.get(self.parent.path);
      parentReg.ctx.children.remove(self.ref);
    }

    debug('%s :: stop actor complete', path);
    next();
  }

  async.series([
      stopDelivery
    , stopChildren
    , stopListeners
    , stopActor
  ], cb);
};

// TODO: make async
Context.prototype.startChild = function (name) {
  var children = this.children
    , childRef = name instanceof Ref
      // TODO: also look at objects with "name" property
      ? name
      : children.get(name)
    , match = children.find({ path: childRef.path });

  if (!match.length) {
    return undefined;
  }

  var ctx = this.system.registry.get(childRef.path).ctx;

  nextTick(function () {
    ctx.start();
  });

  return childRef;
};

Context.prototype.stopChild = function (name, cb) {
  cb = cb || function () {};
  var children = this.children
    , childRef = name instanceof Ref
      ? name
      : children.get(name)
    , match = children.find({ path: childRef.path });

  if (!match.length) {
    return cb([ new Error(childRef.path + ' is not a child of ' + this.ref.path) ]);
  }

  var ctx = this.system.registry.get(childRef.path).ctx;

  ctx.stop(function (err) {
    if (err) return cb(err);
    cb(null);
  });
};

function suspendDelivery (registry, ctx, done) {
  done = done || function () {};
  var path = ctx.ref.path
    , reg = registry.get(path);

  function suspendChildren () {
    var children = [];

    ctx.children.each(function (childRef) {
      var child = registry.get(childRef.path);
      if (child.ctx) children.push(child.ctx);
    });

    async.forEach(children, function (childCtx, next) {
      suspendDelivery(registry, childCtx, next);
    }, done);
  }

  if (reg.mailbox.started) {
    reg.mailbox.stop(function () {
      debug('%s :: message delivery suspended', path);
      suspendChildren();
    });
  } else {
    suspendChildren();
  }
}

function resumeDelivery (registry, ctx) {
  var path = ctx.ref.path
    , reg = registry.get(path);

  reg.mailbox.start();
  debug('%s :: message delivery resumed', path);
  return;

  // NOT recursive unless restart?
  ctx.children.each(function (childRef) {
    var child = registry.get(childRef.path);
    if (child.ctx) resumeDelivery(registry, child.ctx);
  });
}
