/*!
 * Apollo - Mailbox
 * Copyright (c) 2012 Jake Luer <jake@qualiancy.com>
 * MIT Licensed
 */

/*!
 * Module dependencies
 */

var debug = require('sherlock')('apollo:mailbox')
  , nextTick = require('breeze-nexttick')
  , Queue = require('breeze-queue');

/*!
 * Primary export
 */

module.exports = Mailbox;

function Mailbox (registry, ref, opts) {
  var self = this;
  opts = opts || {};

  var queue = new Queue(function (msg, next) {
    processMessage.call(self, msg, next);
  }, opts.concurrency || 100);

  // don't care about errors (for now)
  queue.onerror = function (err) {
    debug('queue error');
    queue._err = false;
    queue.process();
  };

  this.queue = queue;
  this.ref = ref;
  this.registry = registry;
  this.started = false;
}

Mailbox.prototype.push = function (msg) {
  debug('%s :: queueing [%s]', this.ref.path, msg.event);
  this.queue.push(msg, doneHandler.bind(this), this.started);
  nextTick(this.process.bind(this));
};

Mailbox.prototype.process = function () {
  if (!this.started) return this;
  this.queue.process();
  return this;
};

Mailbox.prototype.start = function () {
  debug('%s :: start message processing', this.ref.path);
  this.started = true;
  return this.process();
};

Mailbox.prototype.stop = function (cb) {
  cb = cb || function () {};
  debug('%s :: stopping message processing', this.ref.path);
  if (!this.started) return cb();
  this.started = false;

  var queue = this.queue;

  queue.drain = function () {
    queue.drain = null;
    cb();
  };

  queue.pause();
  if (queue.workers === 0) queue.drain();
  return this;
};

function processMessage (msg, out) {
  debug('%s :: processing [%s]', this.ref.path, msg.event);
  var self = this
    , ev = msg.event
    , index = 0
    , path = this.ref.path
    , reg = this.registry.get(path)
    , stack = reg.emitter.listeners(ev)

  // get parent actor
  function parentActor () {
    var parentPath = reg.ctx.parent.path
      , parent = self.registry.get(parentPath);
    return parent ? parent.actor : null;
  }

  // handle error
  function errorHandler (err) {
    var ev = [ 'child', 'error' ]
      , parent = parentActor.call(self);

    if (parent) {
      debug('emitting child::error to parent of %s', path, err.message);
      parent.emit(ev, err, self.ref);
    }

    out();
  }

  // iterate through message stack
  function iterate () {
    var fn = stack[index++];
    if (!fn) return out();

    function next (err) {
      if (err) return errorHandler(err);
      iterate();
    }

    msg.requeue = function () {
      next();
      nextTick(function () {
        self.push(msg);
      });
    };

    msg.done = next;

    fn(msg, next);
  }

  iterate();
}

function doneHandler (err, msg) {
  var args = [].slice.call(arguments)
    , err = args[0];
}
