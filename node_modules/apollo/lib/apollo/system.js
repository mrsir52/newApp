/*!
 * Apollo - Actor System
 * Copyright (c) 2012 Jake Luer <jake@qualiancy.com>
 * MIT Licensed
 */

/*!
 * Module dependencies
 */

var async = require('breeze-async')
  , debug = require('sherlock')('apollo:system')
  , EventEmitter = require('drip').EnhancedEmitter
  , extend = require('tea-extend')
  , inherits = require('tea-inherits')
  , nextTick = require('breeze-nexttick');

/*!
 * Internal Dependancies
 */

var Actor = require('./actor')
  , actors = require('./actors')
  , Children = require('./children')
  , Context = require('./context')
  , Dispatcher = require('./dispatcher')
  , factory = require('./factory')
  , message = require('./messages')
  , path = require('./path')
  , Ref = require('./ref')
  , Registry = require('./registry')
  , util = require('./util');

/*!
 * Primary export
 */

module.exports = System;

/**
 * ## System API
 *
 * An Actor System is the root of a nested
 * collection of Actors. It will manage the
 * default transport for a given actor feature
 * set.
 *
 * @header System API
 */

function System (name) {
  /*!
   * @param {String} name
   */

  // check valid name
  if (name && !(/^[a-z0-9][a-z0-9_-]*$/.test(name))) {
    throw new Error('Invalid system name.');
  } else if (!name) {
    name = 'user';
  }

  // system specific constructors
  this.registry = new Registry();
  this.dispatcher = new Dispatcher(this.registry);

  // root and first level actors
  this.root = factory.actorOf(Context, this, null, { name: '', spec: actors.root });
  factory.actorOf(Context, this, this.root, { name: '_deadLetter', spec: actors.deadLetter });
  factory.actorOf(Context, this, this.root, { name: '_system', spec: actors.system });
  this.ref = factory.actorOf(Context, this, this.root, { name: name, spec: actors.user });

  // children reference
  this.children = this.registry.lookup(this.ref).ctx.children;
}

System.prototype.register = function (ctx, spec, opts) {
  var self = this;

  if (!(ctx instanceof Context)) {
    throw new Error('Register requires a context.');
  }

  Object.defineProperty(ctx.ref, 'tell', {
    value: function (ev) {
      var tell = new message.tell.Builder(ev, ctx.parent);

      nextTick(function () {
        var msg = tell.serialize();
        msg.recipient = ctx.ref.serialize();
        msg.timestamp = new Date().getTime()
        self.dispatcher.dispatchTell(ctx.ref, msg);
      });

      return tell;
    }
  });

  Object.defineProperty(ctx.ref, 'ask', {
    value: function (ev) {
      var ask = new message.ask.Builder(ev, ctx.parent);

      nextTick(function () {
        var cb = ask._cb
          , msg = ask.serialize();
        msg.recipient = ctx.ref.serialize();
        msg.timestamp = new Date().getTime()
        self.dispatcher.dispatchAsk(ctx.ref, msg, function () {
          cb.apply(ctx.ref, arguments);
        });
      });

      return ask;
    }
  });

  var res = this.registry.add(ctx, spec, opts);

  if (spec && spec.children) {
    registerChildren(ctx, spec.children, opts);
  }

  return res;
};

System.prototype.unregister = function (ref) {
  this.registry.remove(ref);
  return true;
};

/**
 * ### .actorOf (meta[, options])
 *
 * @param {Mixed} actor constructor or remote address
 * @param {Object} options
 * @name actorOf
 * @api public
 */

System.prototype.actorOf = function (name, spec, opts) {
  // check valid name
  if (name && !(/^[a-z0-9][a-zA-Z0-9_-]*$/.test(name))) {
    throw new Error('Invalid actor name.');
  }

  // use factory to construct ref
  return factory.actorOf(Context, this, this.ref, {
      name: name
    , spec: spec
    , opts: opts
  });
};

System.prototype.actorFor = function (slug) {
  slug = path.resolve(this.ref.path, slug);
  var reg = this.registry.get(slug);
  return reg ? reg.ref : null;
};

System.prototype.shutdown = function (cb) {
  cb = cb || function () {};
  var self = this
    , registry = this.registry;

  function stop (path) {
    return function (next) {
      var reg = registry.get(path);
      reg.ctx.stop(next);
    };
  }

  debug('system shutting down NOW!');

  async.series([
      stop(self.ref.path)
    , stop('/_deadLetter')
    , stop('/_system')
    , stop('/')
  ], function () {
    debug('system shutdown complete');
    cb();
  });
};

function registerChildren (ctx, children, opts) {
  var kids = Object.keys(children)
    , kidOpts = extend({}, opts, { start: false });

  kids.forEach(function (kid) {
    var spec = children[kid];
    ctx.actorOf(kid, spec, kidOpts);
  });
}
