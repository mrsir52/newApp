/*!
 * Apollo - Actor
 * Copyright (c) 2012 Jake Luer <jake@qualiancy.com>
 * MIT Licensed
 */

/*!
 * Module dependencies
 */

var debug = require('sherlock')('apollo::actor')
  , EventEmitter = require('drip').EnhancedEmitter
  , inherits = require('tea-inherits')
  , type = require('tea-type');

/*!
 * Internal dependancies
 */

var util = require('./util');

/*!
 * Primary export
 */

module.exports = Actor;

/**
 * ## Actor API
 *
 * An Actor is descrete unit of work or plugin
 * in a specific actor system. An actor's state
 * can at any time be serialized and transported
 * over the wire and represented by an actor proxy
 * at the other end of the wire. The states will
 * remain in sync. In the case of conflicts, the
 * source Actor will take presidence.
 *
 * Actors should not be created directly, but through
 * a parent ActorSystem|Actor's `actorOf` method. Instead
 * `extend` the Actor constructor to create reusable
 * plugins or provide a an object to be used as the
 * prototype.
 *
 * #### Events
 *
 * - `start` - upon actor construction
 * - `error` - upon error sending or recieving messages
 * - `shutdown` - upon receiving the shutdown signal
 *
 * @header Actor API
 */

function Actor (context, ref, emitter) {
  EventEmitter.call(this, { delimeter: '::' });

  Object.defineProperty(this, 'ctx', {
      get: function () {
        return context;
      }
    , enumerable: true
  });

  Object.defineProperty(this, 'ref', {
      get: function () {
        return ref;
      }
    , enumerable: true
  });

  bindEvents.call(this, this.events || {});
  bindMessages.call(this, emitter, this.receive || {});
}

/*!
 * Inherits from `Drip` event emitter
 */

inherits(Actor, EventEmitter);

/*!
 * bindEvents (events)
 *
 * Given an object of key/value events
 * to callbacks, mount the events to the
 * emitter listener.
 *
 * @param {Object} events
 * @api private
 */

function bindEvents (events) {
  var self = this
    , evs = Object.keys(events)
    , path = this.ctx.ref.path;

  function iterate (ev) {
    var fns = Array.isArray(events[ev])
      ? events[ev]
      : [ events[ev] ];

    debug('%s :: binding event [%s] to %d callback(s)', path, ev, fns.length);

    fns.forEach(function bind (fn) {
      var cb = type.is(fn, 'function') ? fn : self[fn];
      self.on(ev, function () {
        debug('%s :: event trigger [%s]', path, ev);
        cb.apply(self, arguments);
      });
    });
  }

  // do iteration binding
  evs.forEach(iterate);
}

function bindMessages (emitter, receive) {
  var self = this
    , msgs = Object.keys(receive)
    , path = this.ctx.ref.path;

  function iterate (msg) {
    var fns = Array.isArray(receive[msg])
      ? receive[msg]
      : [ receive[msg] ];

    debug('%s :: binding message [%s] to %d callback(s)', path, msg, fns.length);

    fns.forEach(function bind (fn) {
      var cb = type.is(fn, 'function') ? fn : self[fn];
      emitter.on(msg, function () {
        debug('%s :: message receive [%s]', path, msg);
        cb.apply(self, arguments);
      });
    });
  }

  msgs.forEach(iterate);
};
